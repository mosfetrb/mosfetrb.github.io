---
layout: page
title:  "湖"
author: mosfet
tags: 场景
---
创建地形自然景观很有趣，山脉和水面、海面、森林等等。有丰富的想象空间……  
本文渲染了一种简单的湖面场景，程序是我较早期的实现。  

## 场景
该场景包含环境纹理，一个相机、两个平面，其中一个用于模拟带有波浪的湖面，该湖面使用FBM`f(xy) -> z`以产生自相似的波浪。另一个用于显示水底，水底具有位移贴图变成一些合理的石子堆，然后程序自动计算标准向量，之所以强调这一点是你不需要从[polyhaven.com](https://polyhaven.com/textures)这样的网站下载纹理资源时一起下载标准向量纹理。  
这些水层通常涉及透明材质，但为了简单尽可能减少使用反射和折射的次数，目前使它们在迭代两到三次后会击中水底并停止。  

<iframe src="https://editor.p5js.org/mosfet-archive/full/pSWYbipdv" width="820" height="510"></iframe>

## 步骤
我们可以通过我们对水面的建模要求进行初步分析以检查是否存在可用的导出SDF。唯一可以做的事情是查看脚下的曲面是什么，这是由于参数曲面本身的行为的情况。但是幸运的是我们可以不用真的沿着路线以固定小步摸索，高度差可以作为作为距离的指导。可以轻松验证这一点，尽管将它作为SDF时距离不是线性减少的。  

<div class="x la bdl2 pdl2 sk bg-cloud07 tx-antiqueRuby1">
<p>
参数曲面也有点“隐含”吗？因为我们仍然需要给出参数才能看到它的一部分？  
</p>

<p>
有趣的想法！虽然参数化曲面和隐式曲面的定义方式有所不同，但确实存在一些相互作用。
因此，虽然参数化曲面为您提供直接控制，但您仍然需要指定参数。它与其说是“隐藏”，不如说是隐含，但你的洞察力并没有错！这 种二元性使几何成为一个极其丰富的探索领域。感觉自己像个几何学家了吗？
</p>
</div>

```cpp
float ocean_para( in vec2 st) {
  vec2 t = vec2(u_time, u_time) * 10.0;
  float z = 0.0;
  float amp = OCEAN_AMP_START;
  for (int i = 0; i < OCEAN_OCTAVES; i++) {
    z += amp * noise(st + t);
    st *= 3.;
    amp *= OCEAN_AMP_GAIN;
  }
  return z;
}
float sdOceanLayer( in vec2 st) {
  return ocean_para(st);
}
float sdf( in vec3 p, in int id) {
  if (id == 1) {
    float zdiff = p.z - sdOceanLayer(p.xy);
    return zdiff;
  } else {
    // return dot(p - vec3(0.0, 0.0, -2.0), vec3(0.0, 0.0, 1.0)) + 0.1;
    return dot(p - vec3(0.0, 0.0, -2.0), vec3(0.0, 0.0, 1.0)) - textureLoad(p, 2).x;
  }
}
```

## 优化
由于显示细节会随着距离的增加而呈反线性衰减，因此我们可以将误差增加到与之相关，这可以节省大量渲染时间。
```cpp
if (traveled < 10.0) {
  if (safe_step < 0.01) return current;
} else {
  if (safe_step < 0.01 + (traveled - 10.0) * 0.005) return current;
}
```

## 着色
这完全取决于预期效果。但最不可缺少的是折射和反射，这两个分量分别计算镜面天空部分和湖底，但反射率的效果有点不同。第三个分量是湖面上的高光，这也有点不同，使用固定线。  
水底照度是"水体颜色+纹理+天空"的乘积，水体颜色可以不考虑。  