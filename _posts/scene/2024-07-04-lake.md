---
layout: page
title:  "湖"
author: mosfet
category: scene
tags: 场景
---
第一次创建自然景观可能很有趣，地形和山脉、水面和海面、森林等等。有很多能做的事。  
这个简单的湖面场景是笔者的早期实现。  

## 场景描述
该场景包含环境纹理，一个相机、两个平面，其中一个用于模拟带有波浪的湖面，该湖面使用FBM`f(xy) -> z`以产生自相似的波浪。另一个用于显示水底，水底具有位移贴图变成一些合理的石子堆，然后程序自动计算标准向量，之所以强调这一点是你不需要从类似[polyhaven.com](https://polyhaven.com/textures)的资源一起下载标准向量纹理。  

<iframe src="https://editor.p5js.org/mosfet-archive/full/3ZQ76doA9" width="760" height="800"></iframe>

## 步骤
我们可以通过我们对水面的建模要求进行初步分析以检查是否存在可用的导出SDF。唯一可以做的事情是查看脚下的曲面是什么，这是由于参数曲面本身的行为带来的境况。但是幸运的是我们可以不用真的沿着路线以固定小步摸索，高度差可以直接作为估计距离的指导。可以轻松验证这一点的合理性，尽管将它作为SDF时距离不是线性减少的。  

<div class="x la bdl2 pdl2 sk bg-gunmetal05 tx-antiqueRuby1">
<p>
参数曲面也有点“隐含”吗？因为我们仍然需要给出参数才能看到它的一部分？  
</p>

<p>
有趣的想法！虽然参数化曲面和隐式曲面的定义方式有所不同，但确实存在一些相互作用。
因此，虽然参数化曲面为您提供直接控制，但您仍然需要指定参数。它与其说是“隐藏”，不如说是隐含，但你的洞察力并没有错！这种二元性使几何成为一个极其丰富的探索领域。感觉自己像个几何学家了吗？
</p>
</div>

```cpp
float ocean_para( in vec2 st) {
  vec2 t = vec2(u_time, u_time) * 10.0;
  float z = 0.0;
  float amp = OCEAN_AMP_START;
  for (int i = 0; i < OCEAN_OCTAVES; i++) {
    z += amp * noise(st + t);
    st *= 3.;
    amp *= OCEAN_AMP_GAIN;
  }
  return z;
}
float sdOceanLayer( in vec2 st) {
  return ocean_para(st);
}
float sdf( in vec3 p, in int id) {
  if (id == 1) {
    float zdiff = p.z - sdOceanLayer(p.xy);
    return zdiff;
  } else {
    // return dot(p - vec3(0.0, 0.0, -2.0), vec3(0.0, 0.0, 1.0)) + 0.1;
    return dot(p - vec3(0.0, 0.0, -2.0), vec3(0.0, 0.0, 1.0)) - textureLoad(p, 2).x;
  }
}
```

## 交叉优化
由于显示细节会随着距离的增加而呈反线性衰减，因此我们可以将误差增加到与之相关，这可以节省大量渲染时间。
```cpp
if (traveled < 10.0) {
  if (safe_step < 0.01) return current;
} else {
  if (safe_step < 0.01 + (traveled - 10.0) * 0.005) return current;
}
```

## 反射率调整
像钻石和水这样透明的介电材料，表面的最终可见状态来自于反射和折射的总和。折射角度遵循Snell’s law，它评估两种介质之间的折射率以及入射光线的角度给出折射角度，在几何上，折射方向确实是反射的完整补集，即另一个半球的方向(与入射光线一致)。但是，方程`sinV = sinv from/to`(其中v是入射)中，我们稍微简化表达式为`sinv=x => Cx(0..1) =sinV`时，确实存在不可求解的折射角度，这取决于常数是多少，其中`C=from/to`指的是从何种介质进入何种介质，空气为`1`，如果从水面`1.333/1`进入空气，则不存在可用的折射角度，代数和现实上都不可能！那么光线去哪里了？实际上在内部发生的是称为全内反射的现象，此时光线只存在镜面反射部分。这就是为什么有时从水下向上望水面像一面镜子，因为光线在这个角度上穿不出去。  
最后一个影响真实性的因素是反射率，它使电介质的反射率根据入射角度调整，反射率指明了反射部分和折射部分的具体比重。这对于累积正确的像素值非常有意义。    
处理这类光线的传输往往被归于光线追踪领域，尤其是这几乎是它一开始的应用。积分形式的光线追踪称为路径追踪问题。更现代的形式是基于物理量辐射的光能建模，而不只是这些简单定律的几何光学。  

**而然，本文的最初目的不在于真的积分散射来渲染水层**，这是受到光栅化中的FBO混合技术启发的。它通过已渲染帧的结果来模拟出反射和折射效果。两个FBO以对所有像素一致的方式处理模拟效果，这意味着它们不是遵守物理的。图像中具有所有一致的反射和折射结果。用纹理产生乱流和标准向量。甚至不需要任何标准向量就能混合折射和反射。[您可以在这里理解相关技术](https://www.youtube.com/watch?v=LgnLB07HDSw&t=69s)。  
这种形式的叠加混合，确实是一种快速模拟出结果的有效方法，尤其是在对光效要求不高的情况下。本场景基本上也利用了类似的概念，但引入了部分光线追踪，但它不是经典情况下随机累积单个散射(即根据反射率选择反射和折射)，而是一次计算完成它们的单独图层，最后才根据原有的基本概念进行混合。  

由于我严格限制折射的次数，实际上不可能有光线从湖水的内部向外折射，因此不存在全内反射的问题。水底照度是"水体颜色+纹理+天空"的乘积，水体颜色可以不考虑。镜面反射部分来自天空，最后，通过符合反射率来正确叠加事实。  
最后一个有趣的分量是水面的高光，高光通常指的是经典着色模型的第二个分量。它不属于光线追踪领域。我们把反射光方向当作视方向，使环境太阳方向成为光源并使用它的颜色，它的照明于环境纹理中的阳光保持一致！一般而言，这种分量用于为水面追加波光粼粼的效果。  