---
layout: page
title:  "混合密度"
author: mosfet
category: miscellaneous
tags: 杂项 渲染器
---
混合密度的尝试[(见)](https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html)。留存一些笔记和记录，而然结论无法保证正确性。  
## 测试
<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/4-1.png">
    </div>
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/4-2.png">
    </div>
  </div>
  <p>图1：完全间接照明(经典情况)、关闭直接采样</p>
</div>

<div class="x gr txac">
  <div class="x la flex mg0">
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/4-3.png">
    </div>
    <div class="x la item6-lg item12 pd0">
      <img src="/assets/i/4-4.png">
    </div>
  </div>
  <p>图2：完全间接照明(经典情况)、打开灯光采样</p>
</div>

---
## 记录
`g/p = ρLcosθ/p`  
我们要注意ρ(i,o)，以及g/p中的p项，其中p是采样散射的分布。  
朗伯BRDF等于`ρ = self.albedo/Pi`。带入方程，`g/p = L* A/PI dot(n, out) / p`。  
因此我们采样散射线，随机生成。注意我们原来用的朗伯散射生成向量垂直方向本身具有更大概率。  

(5)  
注意他所谓的散射分布，压根就不在方程里。我用`sp`来表示好了。这个散射分布是cos相关的那个。  
现在将该散射分布`sp`推导为**显式(对程序而言)**密度函数。  
散射半球的积分为1，并且朗伯是一个正比函数`sp = C * cosθ`(随着角度具有更大概率或配重)。则很容易给出`C = 1/pi -> sp = cosθ / pi`。有些积分技巧总是可以注意，例如将半球转为二维。  

(6)  
在`albedo *= sp * self.albedo / (1.0 / C_TWO_PI);`中，加入了比率`朗伯sp/均匀采样密度p`，密度均匀。注意我们仍然使用相同的散射方式(n+rd)，这似乎是根本无关的(再次确认无关。图像结果一样，但变亮)。  

接下来改为`p = sp = 1/ 2pi`。并且把散射方式(材料)改为半球反射。结果和半球完全一致(原来的材料)。因为我们只是加了一个等于`1`的比率。  

相同的材料不会影响收敛结果，采样PDF仅影响收敛速度。因为你需要更多样本显示分布差异，结果本身只受材料的散射行为影响。改变材质将从根本上改变渲染，算法将收敛到不同的答案。  

存在的差异不仅仅是"噪音"。高大的盒子正面颜色更加均匀。如果您不确定材质的最佳采样模式是什么，那么继续假设均匀的PDF是相当合理的，虽然这可能会缓慢收敛，但它不会破坏您的渲染。
也就是说，如果您不确定材质的正确采样模式是什么，那么您选择的PDF并不是您最关心的问题，因为错误地选择散射函数会毁掉您的渲染。至少它会产生错误的结果。
您可能会发现自己遇到了蒙特卡洛程序中最难发现的错误 - 产生合理外观图像的错误！您不会知道该错误是在程序的第一个版本中，还是在第二个版本中，或者两者都存在！

## 灯密度(9)
我们知道，直接照明问题可能关于阴影光线。而然，可以通过将散射完全指向灯光获得类似的效果，因为这说明表面仅可能被来自灯光的光线照亮。对于散射而言，直接让散射指向采样的光线。这可能很抽象。  
我们选择指向光源的散射方向并计算对应的`p`。结果为`sp / lp`。  

`随机采样灯光线(grab-p) -> 计算采样分布 -> /PDF`。  

但我们需要知道`p(v)`，这样我们的渲染就不会产生偏差。但那是什么？  
```ruby
# 最好将点和角度视为微面和微立体角。dA dv，dA比dv的面积大得多，这是有道理的
# 我们通过采样dA(知道其概率)进而采样dv(的概率)，因此可以获得正确的p
P(dA) = 1 / A   # 1/A
p(dv) = ?        #

# 面积dA、dv存在几何关系
dv = dAcosθ / dot(grab-p, grab-p)  # 注意，将其视为面积，而点则只是点，提供距离
# 由于采样概率相同
  p(dv) = p(da)    # 这里可以视为点………
p(dv)dv = p(da)dA

p(dv) = dot(grab-p,grab-p)/ cosθA
```
```cpp
float p_lights( in vec3 scat, in vec3 n, in float area) {
  float dist_square = dot(scat, scat);
  scat = normalize(scat);
  float n_cosine = dot(n, scat);
  if (n_cosine < 0.0) return -1.0; // 拒绝与灯相背离的遮挡表面
  float lpdf = dist_square / (dot(n, scat) * area);
  return lpdf;
}
```

## 混合模式(10)
我们已经知道如何将散射线"引导"至灯源，这样它就不会采集其他光线，并在下一次击中灯具结束。  
当然，我们要计算上面的几何公式，然后给出`lp`。  
出于这样的目的的材料是漫射材料，因为改变金属和介电的散射行为很难说需要做什么。  
```cpp
vec3 rayi = ray_path;
float sp, lp, area;
bool scat_naturally = false;

LightScatPath(p, scat_naturally, ray_path, area);
if (scat_naturally) Lambertian(material, normal, ray_path);

sp = sp_lambertian(ray_path, normal);
lp = scat_naturally ? sp : p_lights(ray_path, normal, area);
if (lp == -1.0) return vec3(0.0);
albedo *= sp * material.albedo / (0.5 * (lp + sp));
```
混合模式是`albedo *= sp * material.albedo / (0.5 * (lp + sp));`。  
我们让`LightScatPath`决定选择什么散射线，并隐式地将天空当作光源，一旦它被选择，则我们不应该做任何处理，这应该使这样大的一个光源返回自然的漫射结果(就像我们在经典光线追踪里那样)。这种情况下，`lp = sp`，因为它不需要计算对于引导灯具光线的采样。  
总之，总是评估材料散射分布`sp`，再混合和项中的两种密度`sp,lp`。其中，`sp = 散射分布`，因为它们从实际用的散射方法的分布推导中出来相等。  

## 阴影光线呢？(11)
`混合密度(mixture-density)`是更传统的**阴影光线**的替代方法。除了灯光之外，还可以对窗户或门下明亮的裂缝或任何您认为可能明亮或重要的东西进行采样。但大多数专业路径追踪器中看到阴影光线也是很正常的。  
对于粗略结果来说，阴影光线往往比混合密度更便宜，并且在实时中变得越来越普遍。  

## 尾章(12)
玻璃物体很难很好地渲染，除了灯光以外可能还需要对此进行重要性采样。  

12.3.  
略暂不实现。  